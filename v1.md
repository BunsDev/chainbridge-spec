# ChainBridge Version 1 Specification

## Summary

Chainbridge is a modular multi-directional blockchain bridge to allow data and value transfer between any number of blockchains. This should enable users to specify a destination blockchain from their source chain, and send data to that blockchain for consumption on the destination chain. This could be a token that is locked on ChainA and redeemed on ChainB, or an operation that is pre-signed that can be generically executed on another blockchain. The bridge should maintain a set of relayers (see [definitions](#Definitions)) that are authorized to make & process transfers across the different blockchains. The bridge design should be modular enough that the addition of a new type of transfer should not require a full re-deployment of the suite of tools, rather small modular upgrades.

## Definitions
- `Account`: a user on a blockchain
- `Address`: unique identifier for a user on a given blockchain. Commonly the public key from a keypair.
- `Token`: the representation of an asset, which an account can "own".
- `Home Chain`: every token has a `Home Chain`, which is the chain where the token primarily exists.
- `Native Token`: the underlying token of a blockchain that secures the network.
- `Synthetic Token`: a representation of a Token on any chain that is not the `Home Chain`.
- `Event`: a piece of data stored on-chain, explaining that a certain operation occurred.
- `Relayer`: an account that has the ability to call functions not available to the public, also responsible for running the bridge software.
- `Proposal`: a transfer request from one chain to another.
- `Threshold`: the number of required votes to pass a proposal.
- `Handler`: a method which resolves the transfer of data
- `Hash`: some hashing algorithm, this does not need to be standardized across all blockchains.
- `ChainId`: a unique identifier associated with a single chain
- `Handler`: Responsible for decoding deposits, typically paired with a Safe. Note: Handlers have a relationship between blockchains. The metadata field must be standardized between every blockchain.

## Requirements of a bridgeable chain

## Transfer flow

Including proposal creation and actual transfer handling. Breakdown into user vs. relayer.

#### Relayer flow
A relayer must act upon events on a given blockchain, the main ones being deposits and deposit proposals. A relayer has three main components: the listener, writer, and router. The listener is responsible for scanning for events. When it acknowledges that a deposit has been made, it should take the on-chain deposit information construct a [message](#Messaging-Format) accordingly (the specifics are dependent on the [type of transfer](#Transfer-Types)). Once the message is created, it is sent to the router. The router is responsible for handling the payloads between blockchains. This is done to abstract blockchains from one another and allow for modularity when adding support for a new blockchain. The router maintains a registry (mapped to integers or [chainId](#Relayer-Message-Format)) of all the chains that relayer is connected to. This is especially helpful because a listener/writer that requires additional information doesn't need to know anything about a respective chain, it can simply query the router for data from the origin chain. Once the writer receives the message, it checks the [transferType](#Transfer-Types), and formulates the correct transaction to be written to the corresponding chain.

#### User flow
A user only needs to make one transaction to execute a deposit method on a given destination chain. There are only a set of [mandatory](#deposit) deposit parameters, and the remaining mandatory fields depend on the respective [transfer type](#Transfer-Type). After the initial deposit, a user should not be required to make any additional transactions, and the end result of their deposit should occur on the destination chain.

## On-chain state

This must be shared between every bridgeable chain.

### Constants
|Name |Type |Description |
|-----|-----|------------|
|ChainId |uint8 |See definitions above |

### Deposit
When a user wishes to make a transfer, they must first initiate a deposit. The deposit contains a set of information that is used by the bridge relayers when facilitating a transfer. In some cases an asset can be locked during the deposit process, effectively allowing the bridge itself to take custody of that asset. The full details of a deposit are determined based on the type of transfer that is being performed (see [transfers](#Transfer-Types)), and the unique pieces of data can be found in their respective message format (see [message formats](#Messaging-Format)).

The base requirements for all deposits are:
|Name |Type |User Input |Description |
|-----|-----|-----------|------------|
|Destination Chain |ChainId |Yes |The chain where a deposit proposal should be created |
|ResourceId |ResourceId |No |The unique id generate for a deposit |

Note: User Input denotes whether or not the information is required by the user. If No, it is assumed to be automatically generated on-chain or by the relayer.

## Messaging Format

Format of `transfer` and `arbitrary` messages. With examples!
----
To successfully make a deposit, a relayer needs a certain amount of information from a deposit to correctly from the deposit proposal on the destination chain. This section covers the different transfer types a relayer is responsible. The router for handling the payloads between blockchains. This is done to abstract blockchains from one another and allow for modularity when adding support for a new blockchain.esponsible for.

When a relayer handles a transfer, it requires some additional data that is unique based on the transfer type. The base format for the relayer can be found at the [Relayer Message Format](#Relayer-Message-Format) section. The unique data assosiated to a transfer type is filled in the `payload` field.

### Transfer Types
The following transfer types *must* be supported on all chains.
|Event|Description|
|-----|-----------|
|FungibleTransfer| A transfer for tokens that have divisibility (i.e erc20)|
|NonFungibleTransfer| A transfer for tokens that are unique (i.e an NFT/erc721)|
|GenericTransfer| A transfer of random bytes|

### Resource Id
All transfers contain a resource Id. The resourceId is a way for chains to keep track of where a piece of data originated from. Every chain handles data differently; Ethereum uses smart contracts, Substrate uses pallets. This is a fairly extensible solution that all chains must follow. The `resourceId` is broken down into two pieces: the chain id, and the unique string. This is packed together into a byte array of length 32. The first 31 bytes are for the unique string and the last byte is the chainId.
```go
type chainId uint8
type uniqueString [31]byte
type resourceId [32]byte // (uniqueString [31]byte + chainId [1]byte)
```

#### FungibleTransfer
|Name|Type|User Input|Description|
|----|----|----------|-----------|
|amount |uint256 |Yes |The total number of tokens to transfer between chains|
|recipient |[32]byte |Yes |The recipient address for a user on the destination chain|

#### NonFungibleTransfer
|Name|Type|User Input|Description|
|----|----|----------|-----------|
|resourceId |ResourceId |No |A unique identifier for the specific token see [resource Id](#Resource-ID)|
|recipient |[32]byte |Yes |The recipient address for a user on the destination chain|
|tokenId |uint256 |No |The unique identifier for the NFT|
|metadata |[]byte |No |Additional graffiti that a user can attach to the NFT|

#### GenericTransfer
|Name|Type|Description|
|----|----|-----------|
|payload |[]byte |A variable-sized byte array that should be stored on-chain|

## Relayer interfaces and events

Define what methods will be called on-chain and with what data. Define events that are emitted in response to these calls (if applicable), as well as their respective data.

### Relayer Message Format
The `Message` struct is related to the [Messaging Format](#Messaging-Format) section. This is the internal structure that should be used to handle transfering deposit information from one chain to another.
```go
type ChainId uint8

type Message struct {
	Source       ChainId       // Source where message was initiated
	Destination  ChainId       // Destination chain of message
	Type         TransferType  // type of bridge transfer
	DepositNonce uint32        // Nonce for the deposit
	ResourceId   ResourceId    // The unique identifier for the token
	Payload      []interface{} // data associated with event sequence
}
```
